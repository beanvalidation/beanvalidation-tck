<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by tck-audit.xsl at 2013-01-03 10:13 -->
<specification
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://jboss.com/products/weld/tck/audit"
        xsi:schemaLocation="http://jboss.com/products/weld/tck/audit"
        name="JSR-349: Bean Validation"
        version="1.1.0"
        id="beanvalidation">
    <section id="1" title="Introduction"/>
    <section id="2" title="What's new in 1.1"/>
    <section id="3" title="Constraint Definition"/>
    <section id="3.1" title="Constraint annotation">
        <assertion id="a" testable="false">
            <text>An annotation is considered a generic constraint definition if its retention
                policy contains RUNTIME and if the annotation itself is annotated with
                javax.validation.Constraint
            </text>
        </assertion>
        <assertion id="b" testable="false">
            <text>An annotation is considered a cross-parameter constraint definition (see section
                4.5.2.1) if its retention policy contains RUNTIME and if the annotation itself is
                annotated with javax.validation.CrossParameterConstraint.
            </text>
        </assertion>
        <assertion id="c">
            <text>A Bean Validation constraint is either a generic constraint (marked with
                @Constraint) or a cross-parameter constraint (marked with
                @CrossParameterConstraint). If both annotations are given on an annotation type, a
                ConstraintDefinitionException is raised by the Bean Validation provider.
            </text>
        </assertion>
        <assertion id="d" testable="false">
            <text>Generic constraint annotations can target any of the following ElementTypes: FIELD
                for constrained attributes METHOD for constrained getters and constrained method
                return values CONSTRUCTOR for constrained constructor return values PARAMETER for
                constrained method and constructor parameters TYPE for constrained beans
                ANNOTATION_TYPE for constraints composing other constraints
            </text>
        </assertion>
        <assertion id="e" testable="false">
            <text>Cross-parameter constraint annotations can target any of the following
                ElementTypes: METHOD ANNOTATION_TYPE for cross-parameter constraints composing other
                cross-parameter constraints
            </text>
        </assertion>
        <assertion id="f">
            <text>Applying a constraint annotation to an incompatible type will raise an
                UnexpectedTypeException.
            </text>
        </assertion>
        <assertion id="g">
            <text>If a constraint definition is not valid, a ConstraintDefinitionException is raised
                either at validation time or when the metadata is requested.
            </text>
        </assertion>
    </section>
    <section id="3.1.1" title="Constraint definition properties">
        <assertion id="a">
            <text>A constraint definition may have attributes that are specified at the time the
                constraint is applied to a JavaBean.
            </text>
        </assertion>
        <assertion id="b">
            <text>Annotation elements starting with valid are not allowed</text>
        </assertion>
    </section>
    <section id="3.1.1.1" title="message">
        <assertion id="a">
            <text>Every constraint annotation must define a message element of type String.</text>
        </assertion>
    </section>
    <section id="3.1.1.2" title="groups">
        <assertion id="a">
            <text>Every constraint annotation must define a groups element that specifies the
                processing groups with which the constraint declaration is associated.
            </text>
        </assertion>
        <assertion id="b">
            <text>The type of the groups parameter is Class&lt;?&gt;[].</text>
        </assertion>
        <assertion id="c">
            <text>The default value must be an empty array.</text>
        </assertion>
        <assertion id="d">
            <text>If no group is specified when declaring the constraint on an element, the Default
                group is considered declared.
            </text>
        </assertion>
    </section>
    <section id="3.1.1.3" title="payload">
        <assertion id="a">
            <text>Constraint annotations must define a payload element that specifies the payload
                with which the the constraint declaration is associated.
            </text>
        </assertion>
        <assertion id="b">
            <text>The default value must be an empty array.</text>
        </assertion>
        <assertion id="c">
            <text>Each attachable payload extends Payload.</text>
        </assertion>
    </section>
    <section id="3.2" title="Applying multiple constraints of the same type">
        <assertion id="a">
            <text>The bean validation provider treats regular annotations (annotations not annotated
                by @Constraint) whose value element has a return type of an array of constraint
                annotations in a special way. Each element in the value array are processed by the
                Bean Validation implementation as regular constraint annotations.
            </text>
        </assertion>
    </section>
    <section id="3.3" title="Constraint composition">
        <assertion id="a">
            <text>More formally, each constraint annotation hosted on a constraint annotation is
                applied to the target element and this is done recursively.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="b">
            <text>Note that the main annotation and its constraint validation implementation is also
                applied.
            </text>
        </assertion>
        <assertion id="c">
            <text>By default, each failing constraint generates an error report.</text>
        </assertion>
        <assertion id="d">
            <text>Groups from the main constraint annotation are inherited by the composing
                annotations.
            </text>
        </assertion>
        <assertion id="e">
            <text>Any groups definition on a composing annotation is ignored.</text>
        </assertion>
        <assertion id="f">
            <text>Any payload definition on a composing annotation is ignored.</text>
        </assertion>
        <assertion id="g">
            <text>The property type upon which composed constraint is placed must be compatible with
                all constraints (composing and composed).
            </text>
        </assertion>
        <assertion id="h">
            <text>More specifically, if a composed constraint is marked as @ReportAsSingleViolation,
                the evaluation of the composing constraints stops at the first failing constraint
                and the error report corresponding to the composed constraint is generated and
                returned.
            </text>
        </assertion>
        <assertion id="i">
            <text>Composing annotations can define the value of message and custom attributes
                (excluding groups and payload) but these are fixed in the composed constraint
                definition.
            </text>
        </assertion>
        <assertion id="j">
            <text>It is possible to override attributes and messages defined on a composing
                annotation. An attribute from the main annotation is used to override one or more
                attributes of the composing annotations. Such an attribute is annotated with the
                @OverridesAttribute annotation or its multivalued equivalent
                @OverridesAttribute.List.
            </text>
        </assertion>
        <assertion id="k">
            <text>The types of the overridden and overriding attributes must be identical.</text>
        </assertion>
        <assertion id="l">
            <text>A composing constraint can itself be a composed constraint. In this case,
                attribute values are overridden recursively according to the described rules.
            </text>
        </assertion>
        <assertion id="m">
            <text>If a constraint is used more than once as a composing constraint, the multi value
                constraints model as described in 3.2 is used.
            </text>
        </assertion>
        <assertion id="n">
            <text>To select a specific composing constraint, OverridesAttribute.constraintIndex is
                used. It represents the constraint index in the value array.
            </text>
        </assertion>
        <assertion id="o">
            <text>If index is undefined, the single constraint declaration is targeted.</text>
        </assertion>
        <assertion id="p">
            <text>If the composition is invalid, e.g. infinitely recursive composition wrong
                attribute overriding a single attribute mapped to more than one source attribute A
                composing and composed constraint marked as different constraint types (i.e.,
                generic with @Constraint and cross-parameter with @CrossParameterConstraint) etc. a
                ConstraintDefinitionException is raised either at validation time or when the
                metadata is requested.
            </text>
            <note>Needs update</note>
        </assertion>
    </section>
    <section id="3.4" title="Constraint validation implementation">
        <assertion id="a">
            <text>A constraint validation implementation performs the validation of a given
                constraint annotation for a given type.
            </text>
        </assertion>
        <assertion id="b">
            <text>The implementation classes are specified by the validatedBy element of the
                @Constraint respectively @CrossParameterConstraint annotation that decorates the
                constraint definition.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="c" testable="false">
            <text>The constraint validation implementation implements the ConstraintValidator
                interface.
            </text>
        </assertion>
        <assertion id="d" testable="false">
            <text>Some restrictions apply on the generic type T (used in the isValid method). T must
                resolve to a non parameterized type (i.e. because the type is not using generics or
                because the raw type is used instead of the generic version) or generic parameters
                of T must be unbounded wildcard types (i.e. &lt;?&gt;).
            </text>
        </assertion>
        <assertion id="e">
            <text>If A is a cross-parameter constraint annotation type, T must resolve to Object[]
                in order to have the array of parameter values passed to the isValid() method.
            </text>
        </assertion>
        <assertion id="f">
            <text>The initialize method is called by the Bean validation provider prior to any use
                of the constraint implementation.
            </text>
        </assertion>
        <assertion id="g">
            <text>The isValid method is evaluated by the Bean Validation provider each time a given
                value is validated.
            </text>
        </assertion>
        <assertion id="h" testable="false">
            <text>It returns false if the value is not valid, true otherwise.</text>
        </assertion>
        <assertion id="i" testable="false">
            <text>isValid implementations must be thread-safe.</text>
        </assertion>
        <assertion id="j">
            <text>If the property is of an unanticipated type, an UnexpectedTypeException is
                raised.
            </text>
        </assertion>
        <assertion id="k">
            <text>If an exception occurs either in the initialize or isValid method, the runtime
                exception is wrapped into a ValidationException by the Bean Validation engine.
            </text>
        </assertion>
        <assertion id="l" testable="false">
            <text>The constraint validation implementation is not allowed to change the state of the
                value passed to isValid.
            </text>
        </assertion>
        <assertion id="m">
            <text>By default, each invalid constraint leads to the generation of one error object
                represented by a ConstraintViolation object. This object is built from the default
                constraint message template as defined by the constraint declaration and the context
                in which the constraint declaration is placed (bean, property, attribute, method or
                constructor parameter, method or constructor return value).
            </text>
        </assertion>
        <assertion id="n">
            <text>The ConstraintValidatorContext methods let the constraint implementation disable
                the default ConstraintViolation generation and create one or more custom ones.
            </text>
        </assertion>
        <assertion id="o">
            <text>The non-interpolated message passed as a parameter is used to build the
                ConstraintViolation message (the message interpolation operation is applied to it).
            </text>
        </assertion>
        <assertion id="p">
            <text>By default, the Path exposed on the ConstraintViolation represents the path to the
                bean, property, parameter or return value hosting the constraint (see 5.2 for more
                information).
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="q">
            <text>You can point it to a subpath of this default path by using the constraint
                violation builder fluent API.
            </text>
        </assertion>
        <assertion id="r">
            <text>If disableDefaultConstraintViolation is called, no custom error is added (using
                the error builder) and if the constraint is not valid, a ValidationException is
                raised.
            </text>
        </assertion>
    </section>
    <section id="3.5" title="The ConstraintValidatorFactory">
        <assertion id="a">
            <text>The default ConstraintValidatorFactory provided by the Bean Validation provider
                implementation uses the public no-arg constructor of the ConstraintValidator class.
            </text>
        </assertion>
        <assertion id="b">
            <text>If an exception occurs in the factory while retrieving the ConstraintValidator
                instance, the runtime exception is wrapped in a ValidationException.
            </text>
        </assertion>
        <assertion id="c">
            <text>If the instance returned by the factory is null, a ValidationException is
                raised.
            </text>
        </assertion>
    </section>
    <section id="4" title="Constraint declaration and validation process"/>
    <section id="4.1" title="Requirements on classes to be validated">
        <assertion id="a">
            <text>Properties to be validated must follow the method signature conventions for
                JavaBeans read properties, as defined by the JavaBeans specification.
            </text>
        </assertion>
        <assertion id="b" testable="false">
            <text>Static fields and static methods are excluded from validation.</text>
        </assertion>
        <assertion id="c">
            <text>Constraints can be applied to interfaces and superclasses.</text>
        </assertion>
        <assertion id="d">
            <text>The target of an annotation definition can be a field, property, or type, provided
                that: the constraint definition supports the specified target
                (java.lang.annotation.Target) one of the ConstraintValidators declared on the
                constraint supports the declared type of the target (see 4.6.4).
            </text>
        </assertion>
    </section>
    <section id="4.1.1" title="Object validation">
        <assertion id="a">
            <text>Constraint declarations can be applied to a class or an interface.</text>
        </assertion>
    </section>
    <section id="4.1.2" title="Field and property validation">
        <assertion id="a">
            <text>Constraint declarations can be applied on both fields and properties for the same
                object type.
            </text>
        </assertion>
        <assertion id="b">
            <text>The same constraint should however not be duplicated between a field and its
                associated property (the constraint validation would be applied twice).
            </text>
        </assertion>
        <assertion id="c">
            <text>When a field is annotated with a constraint declaration, field access strategy is
                used to access the state validated by such constraint.
            </text>
        </assertion>
        <assertion id="d">
            <text>When a property is annotated with a constraint declaration, property access
                strategy is used to access the state validated by such constraint.
            </text>
        </assertion>
        <assertion id="e">
            <text>The fields or methods visibility are not constrained.</text>
        </assertion>
    </section>
    <section id="4.1.3" title="Graph validation">
        <assertion id="a">
            <text>Consider the situation where bean X contains a field of type Y. By annotating
                field Y with the @Valid annotation, the Validator will validate Y (and its
                properties) when X is validated.
            </text>
        </assertion>
        <assertion id="b">
            <text>The exact type Z of the value contained in the field declared of type Y (subclass,
                implementation) is determined at runtime. The constraint definitions of Z are used.
            </text>
        </assertion>
        <assertion id="c">
            <text>Any object implementing java.lang.Iterable is supported.</text>
        </assertion>
        <assertion id="d">
            <text>Arrays of objects</text>
        </assertion>
        <assertion id="e">
            <text>java.util.Collection</text>
        </assertion>
        <assertion id="f">
            <text>java.util.Set</text>
        </assertion>
        <assertion id="g">
            <text>java.util.List</text>
        </assertion>
        <assertion id="h">
            <text>java.util.Map</text>
        </assertion>
        <assertion id="i">
            <text>For Map, the value of each Map.Entry is validated (the key is not validated).
            </text>
        </assertion>
        <assertion id="j">
            <text>Like regular references, its type is determined at runtime and the constraint
                definitions for this particular type are used.
            </text>
        </assertion>
        <assertion id="k">
            <text>The @Valid annotation is applied recursively.</text>
        </assertion>
    </section>
    <section id="4.3" title="Inheritance (interface and superclass)">
        <assertion id="a">
            <text>A constraint declaration can be placed on an interface.</text>
        </assertion>
        <assertion id="b">
            <text>For a given class, constraint declarations held on superclasses as well as
                interfaces are evaluated by the Bean Validation provider.
            </text>
        </assertion>
    </section>
    <section id="4.4" title="Group and group sequence">
        <assertion id="a">
            <text>If no group is explicitly declared, a constraint belongs to the Default group.
            </text>
        </assertion>
        <assertion id="b">
            <text>Groups are represented by interfaces.</text>
        </assertion>
        <assertion id="c">
            <text>A constraint can belong to one or more groups.</text>
        </assertion>
        <assertion id="d">
            <text>During the validation call, one or more groups are validated. All the constraints
                belonging to this set of group is evaluated on the object graph.
            </text>
        </assertion>
    </section>
    <section id="4.4.1" title="Group inheritance">
        <assertion id="a">
            <text>A group may inherit one or more groups by using interface inheritance.</text>
        </assertion>
        <assertion id="b">
            <text>For a given interface Z, constraints marked as belonging to the group Z (i.e.
                where the annotation element groups contains the interface Z) or any of the super
                interfaces of Z (inherited groups) are considered part of the group Z.
            </text>
        </assertion>
    </section>
    <section id="4.4.2" title="Group sequence">
        <assertion id="a" testable="false">
            <text>By default, constraints are evaluated in no particular order regardless of which
                groups they belong to.
            </text>
        </assertion>
        <assertion id="b">
            <text>Each group in a group sequence must be processed sequentially in the order defined
                by @GroupSequence.value when the group defined as a sequence is requested.
            </text>
        </assertion>
        <assertion id="c">
            <text>Note that a group member of a sequence can itself be composed of several groups
                via inheritance or sequence definition. In this case, each composed group must
                respect the sequence order as well.
            </text>
        </assertion>
        <assertion id="d">
            <text>If one of the groups processed in the sequence generates one or more constraint
                violations, the groups following in the sequence must not be processed.
            </text>
        </assertion>
        <assertion id="e">
            <text>Groups defining a sequence and groups composing a sequence must not be involved in
                a cyclic dependency: either directly or indirectly either through cascaded sequence
                definitions or group inheritance
            </text>
        </assertion>
        <assertion id="f">
            <text>If a group containing such a circularity is evaluated, a GroupDefinitionException
                is raised.
            </text>
        </assertion>
        <assertion id="g" testable="false">
            <text>Groups defining a sequence should not directly inherit other groups. In other
                words, the interface hosting the group sequence should not have any super interface.
            </text>
        </assertion>
        <assertion id="h" testable="false">
            <text>Groups defining a sequence should not be used directly in constraint
                declarations.
            </text>
        </assertion>
        <assertion id="i">
            <text>To define a group as a sequence, the interface must be annotated with the
                @GroupSequence annotation.
            </text>
        </assertion>
        <assertion id="j">
            <text>A given constraint can belong to two or more groups ordered by a sequence. In this
                case, the constraint is evaluated as part of the first group and ignored in the
                subsequent group(s).
            </text>
        </assertion>
    </section>
    <section id="4.4.3" title="Redefining the Default group for a class">
        <assertion id="a">
            <text>To redefine Default for a class, place a @GroupSequence annotation on the class;
                this sequence expresses the sequence of groups that does substitute Default for this
                class.
            </text>
        </assertion>
        <assertion id="b" testable="false">
            <text>Constraints hosted on a class A and belonging to the Default group (by default or
                explicitly) implicitly belong to the group A.
            </text>
        </assertion>
        <assertion id="c">
            <text>A sequence defined on a class A (i.e. redefining the Default groups for the class)
                must contain the group A.
            </text>
        </assertion>
        <assertion id="d">
            <text>If a @GroupSequence redefining the Default group for a class A does not contain
                the group A, a GroupDefinitionException is raised when the class is validated or
                when its metadata is requested.
            </text>
        </assertion>
    </section>
    <section id="4.4.4" title="Implicit grouping">
        <assertion id="a">
            <text>Every constraint hosted on an interface Z and part of the Default group
                (implicitly or explicitly) belongs to the group Z.
            </text>
        </assertion>
    </section>
    <section id="4.4.5" title="Group conversion">
        <assertion id="a">
            <text>@ConvertGroup and @ConvertGroup.List can be used everywhere @Valid can be used
                (associations, method/constructor parameters and return value). If these annotations
                are used without @Valid, a ConstraintDeclarationException is raised.
            </text>
        </assertion>
        <assertion id="b">
            <text>If the group expected to be passed to the nested element validation is defined as
                the from attribute of a @ConvertGroup annotation, the group used to effectively
                validate the nested element is the corresponding group defined in the to attribute.
            </text>
        </assertion>
        <assertion id="c">
            <text>Rules are not executed recursively.</text>
        </assertion>
        <assertion id="d">
            <text>It is not legal to have more than one conversion rule containing the same from
                value. In this case, a ConstraintDeclarationException is raised.
            </text>
        </assertion>
        <assertion id="e">
            <text>Like regular constraint declarations, the from attribute cannot refer to a group
                sequence. A ConstraintDeclarationException is raised in this situation.
            </text>
        </assertion>
        <assertion id="f">
            <text>The to attribute can. The group sequence will then be expanded before validating
                the associated object.
            </text>
        </assertion>
        <assertion id="g">
            <text>@ConvertGroup and @ConvertGroup.List can only be placed where @Valid is present to
                ensure proper respect of the Liskov substitution principle
            </text>
        </assertion>
        <assertion id="h">
            <text>Likewise, if a sub type overrides/implements a method originally defined in
                several parallel types of the hierarchy (e.g. two interfaces not extending each
                other, or a class and an interface not implemented by said class) and if that
                method's return value has been marked for cascading validation in one of the
                parallel types, no group conversion rule may be declared for that method's return
                value in the parallel types of the hierarchy.
            </text>
        </assertion>
        <assertion id="i">
            <text>If any of these rules is violated, a ConstraintDeclarationException is raised by
                default as defined in 4.5.5.
            </text>
        </assertion>
    </section>
    <section id="4.4.6" title="Formal group definitions">
        <assertion id="a">
            <text>If X has no @GroupSequence annotation, the group Default contains the following
                constraints: every constraint in the group X if X has a direct superclass Y, every
                constraint in the group Default of Y
            </text>
        </assertion>
        <assertion id="b">
            <text>If X does have a @GroupSequence annotation, the group Default contains every
                constraint belonging to every group declared by the @GroupSequence annotation.
            </text>
        </assertion>
    </section>
    <section id="4.5" title="Method and constructor constraints"/>
    <section id="4.5.1" title="Requirements on methods to be validated">
        <assertion id="a">
            <text>Constrained methods must be non-static.</text>
        </assertion>
    </section>
    <section id="4.5.2" title="Declare parameter constraints">
        <assertion id="a">
            <text>Parameter constraints are declared by putting constraint annotations on method or
                constructor parameters.
            </text>
        </assertion>
    </section>
    <section id="4.5.2.1" title="Cross-parameter constraints">
        <assertion id="a">
            <text>Cross-parameter constraints are declared by putting cross-parameter constraint
                annotations on methods or constructors
            </text>
        </assertion>
        <assertion id="b">
            <text>Cross parameters constraints are validated at the same time as parameter
                constraints.
            </text>
        </assertion>
    </section>
    <section id="4.5.2.2" title="Naming parameters">
        <assertion id="a">
            <text>A conforming Bean Validation implementation provides a default
                ParameterNameProvider implementation which returns parameter names in the form
                argPARAMETER_INDEX, where PARAMETER_INDEX starts at 0 for the first parameter, e.g.
                arg0, arg1 etc.
            </text>
        </assertion>
        <assertion id="b">
            <text>If an exception occurs during invocation of the getParameterNames() methods, this
                exception is wrapped into a ValidationException by the Bean Validation engine.
            </text>
        </assertion>
    </section>
    <section id="4.5.3" title="Declaring return value constraints">
        <assertion id="a">
            <text>Return value constraints are declared by putting constraint annotations directly
                on a method or constructor.
            </text>
        </assertion>
    </section>
    <section id="4.5.4" title="Marking parameters and return values for cascaded validation">
        <assertion id="a">
            <text>Similar to normal bean validation, the @Valid annotation is used to declare that a
                cascaded validation of the given method parameters or return values shall be
                performed by the Bean Validation provider. When marked, the parameter or return
                value is considered a bean object to validate.
            </text>
        </assertion>
        <assertion id="b">
            <text>Null arguments and null return values are ignored</text>
        </assertion>
        <assertion id="c">
            <text>The validation is recursive; that is, if validated parameter or return value
                objects have references marked with @Valid themselves, these references will also be
                validated
            </text>
        </assertion>
    </section>
    <section id="4.5.5" title="Method constraints in inheritance hierarchies">
        <assertion id="a">
            <text>In sub types (be it sub classes/interfaces or interface implementations) no
                parameter constraints must be declared on overridden or implemented methods, nor may
                parameters be marked for cascaded validation. This would pose a strengthening of
                preconditions to be fulfilled by the caller.
            </text>
        </assertion>
        <assertion id="b">
            <text>If a sub type overrides/implements a method originally defined in several parallel
                types of the hierarchy (e.g. two interfaces not extending each other, or a class and
                an interface not implemented by said class) no parameter constraints may be declared
                for that method at all nor parameters be marked for cascaded validation. This again
                is to avoid an unexpected strengthening of preconditions to be fulfilled by the
                caller.
            </text>
        </assertion>
        <assertion id="c">
            <text>In sub types (be it sub classes/interfaces or interface implementations) return
                value constraints may be declared on overridden or implemented methods and the
                return value may be marked for cascaded validation. Upon validation, all return
                value constraints of the method in question are validated, wherever they are
                declared in the hierarchy; This only poses possibly a strengthening but no weakening
                of the method's postconditions guaranteed to the caller.
            </text>
        </assertion>
        <assertion id="d">
            <text>One must not mark a method return value for cascaded validation more than once in
                a class hierarchy. In other words, sub types (be it sub classes/interfaces or
                interface implementations) cannot mark the return value for cascaded validation if
                the return value has already been marked on a super type or interface.
            </text>
        </assertion>
        <assertion id="e">
            <text>The above rules do not apply when validating constructor constraints as
                constructors do not override one another. Parameter and return value constraints can
                be applied to any constructor in the type hierarchy, but only the constraints
                defined directly on the validated constructor are evaluated.
            </text>
        </assertion>
    </section>
    <section id="4.6" title="Validation routine">
        <assertion id="a" testable="false">
            <text>For a given group, the validation routine applied on a given bean instance is
                expected to execute the following constraint validations in no particular order
            </text>
        </assertion>
        <assertion id="b">
            <text>Note that this implies that a given validation constraint will not be processed
                more than once per validation.
            </text>
        </assertion>
        <assertion id="c" testable="false">
            <text>Unless ordered by group sequences, groups can be validated in no particular
                order.
            </text>
        </assertion>
    </section>
    <section id="4.6.1" title="Object graph validation">
        <assertion id="a">
            <text>The @Valid annotation on a given association (i.e. object reference or collection,
                array, Iterable of objects), dictates the Bean Validator implementation to apply
                recursively the Bean Validation routine on (each of) the associated object(s).
            </text>
        </assertion>
        <assertion id="b">
            <text>This mechanism is recursive: an associated object can itself contain cascaded
                references.
            </text>
        </assertion>
        <assertion id="c">
            <text>Null references are ignored.</text>
        </assertion>
        <assertion id="d">
            <text>To prevent infinite loops, the Bean Validation implementation must ignore the
                cascading operation if the associated object instance has already been validated in
                the current navigation path (starting from the root object).
            </text>
        </assertion>
        <assertion id="e">
            <text>@Valid is an orthogonal concept to the notion of group. If two groups are in
                sequence, the first group must pass for all associated objects before the second
                group is evaluated.
            </text>
        </assertion>
    </section>
    <section id="4.6.2" title="Method validation">
        <assertion id="a">
            <text>For a given group, the validation routine applied to validate parameters of a
                method or constructor is expected to execute the following constraint validations in
                no particular order
            </text>
        </assertion>
        <assertion id="b">
            <text>For a given group, the validation routine applied to validate the return value of
                a method or constructor is expected to execute the following constraint validations
                in no particular order
            </text>
        </assertion>
        <assertion id="c">
            <text>Note that this implies that a given validation constraint will not be processed
                more than once per validation.
            </text>
        </assertion>
        <assertion id="d">
            <text>Unless ordered by group sequences, groups can be validated in no particular
                order.
            </text>
        </assertion>
    </section>
    <section id="4.6.3" title="Traversable property">
        <assertion id="a">
            <text>isReachable is called for every property about to be accessed either for
                validation or for cascading.
            </text>
        </assertion>
        <assertion id="b">
            <text>isCascadable is called for every property about to be cascaded (i.e. marked as
                @Valid).
            </text>
        </assertion>
        <assertion id="c">
            <text>isCascadable for a given property is only called if isReachable returns true. In
                other words, isReachable is always called before isCascadable for a given property.
            </text>
        </assertion>
        <assertion id="d">
            <text>The Bean Validation provider must not access the state of a property, nor validate
                its constraints if the property is not traversable. A property is traversable if
                TraversableResolver returns true for this property.
            </text>
        </assertion>
        <assertion id="e">
            <text>If an exception occurs when the TraversableResolver is called, the exception is
                wrapped into a ValidationException.
            </text>
        </assertion>
        <assertion id="f" testable="false">
            <text>If Java Persistence is available in the runtime environment, a property is
                considered reachable if Java Persistence considers the property as loaded.
            </text>
        </assertion>
        <assertion id="g" testable="false">
            <text>If Java Persistence is not available in the runtime environment, all properties
                are considered reachable.
            </text>
        </assertion>
        <assertion id="h" testable="false">
            <text>All properties are considered cascadable.</text>
        </assertion>
    </section>
    <section id="4.6.4" title="ConstraintValidator resolution algorithm">
        <assertion id="a">
            <text>If the constraint declaration is hosted on a class or an interface, the targeted
                type is the class or the interface.
            </text>
        </assertion>
        <assertion id="b">
            <text>If the constraint is hosted on a class attribute, the type of the attribute is the
                targeted type.
            </text>
        </assertion>
        <assertion id="c">
            <text>If the constraint is hosted on a getter, the return type of the getter is the
                targeted type.
            </text>
        </assertion>
        <assertion id="d">
            <text>The ConstraintValidator chosen to validate a declared type T is the one where the
                type supported by the ConstraintValidator is a supertype of T and where there is no
                other ConstraintValidator whose supported type is a supertype of T and not a
                supertype of the chosen ConstraintValidator supported type.
            </text>
        </assertion>
        <assertion id="e">
            <text>If no ConstraintValidator compliant with T is found amongst the
                ConstraintValidators listed by the constraint A, an UnexpectedTypeException is
                raised.
            </text>
        </assertion>
        <assertion id="f">
            <text>If more than one maximally specific ConstraintValidator is found, an
                UnexpectedTypeException is raised.
            </text>
        </assertion>
    </section>
    <section id="5" title="Validation APIs"/>
    <section id="5.1" title="Validator API">
        <assertion id="a" testable="false">
            <text>Validator implementations are thread-safe.</text>
        </assertion>
    </section>
    <section id="5.1.1" title="Validation methods">
        <assertion id="a">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;...
                groups) is used to validate a given object.
            </text>
        </assertion>
        <assertion id="b">
            <text>An IllegalArgumentException is thrown when null is passed for the object parameter
                or the varargs groups parameter.
            </text>
        </assertion>
        <assertion id="c">
            <text>A Set containing all ConstraintViolation objects representing the failing
                constraints is returned, an empty Set is returned otherwise.
            </text>
        </assertion>
        <assertion id="d">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
                String propertyName, Class&lt;?&gt;... groups) validates a given field or property
                of an object.
            </text>
        </assertion>
        <assertion id="e">
            <text>An IllegalArgumentException is thrown when validateProperty is called and object
                is null or propertyName is null empty or invalid or null is passed to the varargs
                groups parameter.
            </text>
        </assertion>
        <assertion id="f">
            <text>The property name is the JavaBeans property name (as defined by the JavaBeans
                Introspector class).
            </text>
        </assertion>
        <assertion id="g">
            <text>@Valid is not honored by this method.</text>
        </assertion>
        <assertion id="h">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt;
                beanType, String propertyName, Object value, Class&lt;?&gt;... groups) validates the
                property referenced by propertyName present on beanType or any of its superclasses,
                if the property value were value.
            </text>
        </assertion>
        <assertion id="i">
            <text>An IllegalArgumentException is thrown when validateValue is called and object is
                null or propertyName is null empty or invalid or null is passed to the varargs
                groups parameter.
            </text>
        </assertion>
        <assertion id="j">
            <text>@Valid is not honored by this method.</text>
        </assertion>
        <assertion id="k">
            <text>If some unrecoverable failure happens during validation, a ValidationException is
                raised.
            </text>
        </assertion>
    </section>
    <section id="5.1.2" title="Methods for validating method and constructor constraints">
        <assertion id="a">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(T object,
                Method method, Object[] parameterValues, Class&lt;?&gt;... groups) validates the
                arguments (as given in parameterValues) for the parameters of a given method
                (identified by method).
            </text>
        </assertion>
        <assertion id="b">
            <text>A set containing all ConstraintViolation objects representing the failing
                constraints is returned, an empty set is returned if no constraint violation
                occurred.
            </text>
        </assertion>
        <assertion id="c">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(T object,
                Method method, Object returnValue, Class&lt;?&gt;... groups) validates the return
                value (specified by returnValue) of a given method (identified by method).
            </text>
        </assertion>
        <assertion id="d">
            <text>A set containing all ConstraintViolation objects representing the failing
                constraints is returned, an empty set is returned if no constraint violation
                occurred.
            </text>
        </assertion>
        <assertion id="e">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
                validateConstructorParameters(Constructor&lt;T&gt; constructor, Object[]
                parameterValues, Class&lt;?&gt;... groups) validates the arguments (as given in
                parameterValues) for the parameters of a given constructor (identified by
                constructor).
            </text>
        </assertion>
        <assertion id="f">
            <text>A set containing all ConstraintViolation objects representing the failing
                constraints is returned, an empty set is returned if no constraint violation
                occurred.
            </text>
        </assertion>
        <assertion id="g">
            <text>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
                validateConstructorReturnValue(Constructor&lt;T&gt; constructor, T createdObject,
                Class&lt;?&gt;... groups) validates the object (specified by createdObject) of a
                given constructor (identified by constructor).
            </text>
        </assertion>
        <assertion id="h">
            <text>A set containing all ConstraintViolation objects representing the failing
                constraints is returned, an empty set is returned if no constraint violation
                occurred.
            </text>
        </assertion>
    </section>
    <section id="5.1.3" title="groups">
        <assertion id="a">
            <text>All constraints belonging to the targeted group are applied during the 4.6.</text>
        </assertion>
        <assertion id="b">
            <text>If no group is passed, the Default group is assumed.</text>
        </assertion>
        <assertion id="c" testable="false">
            <text>When more than one group is evaluated and passed to the various validate methods,
                order is not constrained.
            </text>
        </assertion>
    </section>
    <section id="5.2" title="ConstraintViolation">
        <assertion id="a">
            <text>The getMessage method returns the interpolated (localized) message for the failing
                constraint
            </text>
        </assertion>
        <assertion id="b">
            <text>The getMessageTemplate method returns the non-interpolated error message</text>
        </assertion>
        <assertion id="c">
            <text>The getRootBean method returns the root object being validated that led to the
                failing constraint
            </text>
        </assertion>
        <assertion id="d">
            <text>The getInvalidValue method returns the value (field, property, method/constructor
                parameter, method/constructor return value or validated object) being passed to
                isValid.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="e">
            <text>For a cross-parameter constraint, an Object[] representing the method/constructor
                invocation arguments is returned.
            </text>
        </assertion>
        <assertion id="f">
            <text>getConstraintDescriptor provides access to the failing constraint metadata</text>
        </assertion>
        <assertion id="g">
            <text>The getPropertyPath method returns the Path object representing the navigation
                path from the root object to the failing object.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="h">
            <text>The runtime type is considered, not the static type. For example if a property is
                declared Collection&lt;String&gt; but its runtime type is ArrayList&lt;String&gt;,
                the property is considered an ArrayList&lt;String&gt;.
            </text>
        </assertion>
        <assertion id="i">
            <text>If the failing object is the root object, a Node with name set to null is added to
                the Path. The Kind of the node's ElementDescriptor is Kind.BEAN.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="j">
            <text>A Node object whose name equals the name of the association property (field name
                or Java Bean property name) is added to Path. The Kind of the node's
                ElementDescriptor is Kind.PROPERTY.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="k">
            <text>If the association is a List or an array, the following Node object added contains
                the index value in getIndex.
            </text>
        </assertion>
        <assertion id="l">
            <text>If the association is a Map, the following Node object added (representing a given
                map entry) contains the key value in getKey
            </text>
        </assertion>
        <assertion id="m">
            <text>For all Iterable or Map, the following Node object added is marked as inIterable
                (isInIterable)
            </text>
        </assertion>
        <assertion id="n">
            <text>For a property level constraint (field and getter) a Node object is added to Path
                whose name equals the name of the property (field name or Java Bean property name).
                The Kind of the node's ElementDescriptor is Kind.PROPERTY. the property path is
                considered complete
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="o">
            <text>For a class level constraint: a Node object is added to Path whose name is null.
                The Kind of the node's ElementDescriptor is Kind.BEAN. the property path is
                considered complete
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="p">
            <text>A Node object is added to the Path which represents the validated method or
                constructor. The name of the node equals the validated method or constructor, the
                Kind of the node's ElementDescriptor is Kind.METHOD respectively Kind.CONSTRUCTOR.
            </text>
        </assertion>
        <assertion id="q">
            <text>A Node object is added to the Path which represents the validated parameter or
                return value. In the parameter case, the name of the node equals the parameter name
                as determined by the current parameter name provider (see 4.5.2.2). In the return
                value case, the name of the node is null. The Kind of the node's ElementDescriptor
                is Kind.PARAMETER respectively Kind.RETURN_VALUE.
            </text>
        </assertion>
        <assertion id="r">
            <text>The property path is considered complete</text>
        </assertion>
        <assertion id="s">
            <text>A Node object is added to the Path which represents the concerned method or
                constructor. The name of the node equals the concerned method or constructor, the
                Kind of the node's ElementDescriptor is Kind.METHOD respectively Kind.CONSTRUCTOR.
            </text>
        </assertion>
        <assertion id="t">
            <text>A Node object is added to the Path which represents the traversed parameter or
                return value. In the parameter case, the name of the node equals the parameter name
                as determined by the current parameter name provider. In the return value case, the
                name of the node is null. The Kind of the node's ElementDescriptor is Kind.PARAMETER
                respectively Kind.RETURN_VALUE.
            </text>
        </assertion>
        <assertion id="u">
            <text>If the parameter/return value is a List or an array, the following Node object
                added contains the index value in getIndex.
            </text>
        </assertion>
        <assertion id="v">
            <text>If the parameter/return value is a Map, the following Node object added
                (representing a given map entry) contains the key value ingetKey.
            </text>
        </assertion>
        <assertion id="w">
            <text>For all Iterable or Map, the following Node object added is marked as inIterable
                (isInIterable)
            </text>
        </assertion>
        <assertion id="x" testable="false">
            <text>Bean Validation implementations should ensure that a ConstraintViolation
                implementation is Serializable provided that the root bean, the leaf bean, the
                invalid value and keys in the Path object are Serializable objects.
            </text>
        </assertion>
    </section>
    <section id="5.3" title="Message interpolation"/>
    <section id="5.3.1" title="Default message interpolation">
        <assertion id="a">
            <text>A conforming implementation includes a default message interpolator.</text>
        </assertion>
        <assertion id="b">
            <text>Each constraint defines a message descriptor via its message property.</text>
        </assertion>
        <assertion id="c">
            <text>Every constraint definition shall define a default message descriptor for that
                constraint.
            </text>
        </assertion>
        <assertion id="d">
            <text>Messages can be overridden at declaration time in constraints by setting the
                message property on the constraint.
            </text>
        </assertion>
        <assertion id="e">
            <text>The message descriptor is a string literal and may contain one or more message
                parameters. Message parameters are string literals enclosed in braces.
            </text>
        </assertion>
        <assertion id="f">
            <text>\{ is considered as the literal { instead of being considered as the beginning of
                a message parameter
            </text>
        </assertion>
        <assertion id="g">
            <text>\} is considered as the literal } instead of being considered as the end of a
                message parameter
            </text>
        </assertion>
        <assertion id="h">
            <text>\\ is considered as the literal \ instead of being considered as the escaping
                character
            </text>
        </assertion>
    </section>
    <section id="5.3.1.1" title="Default message interpolation algorithm">
        <assertion id="a">
            <text>Message parameters are extracted from the message string and used as keys to
                search the ResourceBundle named ValidationMessages
            </text>
        </assertion>
        <assertion id="b">
            <text>Step 1 is applied recursively until no replacement is performed</text>
        </assertion>
        <assertion id="c">
            <text>Message parameters are extracted from the message string and used as keys to
                search the Bean Validation provider's built-in ResourceBundle using the defined
                locale (see below). If a property is found, the message parameter is replaced with
                the property value in the message string.
            </text>
        </assertion>
        <assertion id="d" testable="false">
            <text>Contrary to step 1, step 2 is not processed recursively.</text>
        </assertion>
        <assertion id="e" testable="false">
            <text>If step 2 triggers a replacement, then step 1 is applied again.</text>
        </assertion>
        <assertion id="f">
            <text>Message parameters are extracted from the message string. Those matching the name
                of an attribute of the constraint are replaced by the value of that attribute in the
                constraint declaration.
            </text>
        </assertion>
        <assertion id="g">
            <text>If the locale is passed to the interpolator method interpolate(String, Context,
                Locale), this Locale instance is used.
            </text>
        </assertion>
        <assertion id="h">
            <text>Otherwise, the default Locale as provided by Locale.getDefault() is used.</text>
        </assertion>
    </section>
    <section id="5.3.2" title="Custom message interpolation">
        <assertion id="a" testable="false">
            <text>A message interpolator implementation shall be thread-safe.</text>
        </assertion>
        <assertion id="b">
            <text>It is possible to override the MessageInterpolator implementation for a given
                Validator instance by invoking
                ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator().
            </text>
        </assertion>
    </section>
    <section id="5.5" title="Bootstrapping">
        <assertion id="a">
            <text>A bootstrap implementation must be able to bootstrap any Bean Validation provider
                implementation.
            </text>
        </assertion>
    </section>
    <section id="5.5.1" title="Examples">
        <assertion id="a" testable="false">
            <text>The ValidatorFactory object is thread-safe.</text>
        </assertion>
    </section>
    <section id="5.5.2" title="ValidatorFactory">
        <assertion id="a">
            <text>getMessageInterpolator() returns the MessageInterpolator instance configured
                during the initialization of the ValidatorFactory.
            </text>
        </assertion>
        <assertion id="b">
            <text>getParameterNameProvider() returns the ParameterNameProvider instance configured
                during the initialization of the ValidatorFactory.
            </text>
        </assertion>
        <assertion id="c">
            <text>The MessageInterpolator, the TraversableResolver, the ConstraintValidatorFactory
                or the ParameterNameProvider passed to the ValidatorContext are used instead of the
                ValidatorFactory's MessageInterpolator, TraversableResolver,
                ConstraintValidatorFactory or ParameterNameProvider instances.
            </text>
            <note>Needs update</note>
        </assertion>
    </section>
    <section id="5.5.3" title="Configuration">
        <assertion id="a">
            <text>Configuration does provide a ParameterNameProvider implementation following the
                default Bean Validation ParameterNameProvider rules as defined in 4.5.2.2. You can
                access it by calling getDefaultParameterNameProvider()
            </text>
        </assertion>
        <assertion id="b">
            <text>Via getBootstrapConfiguration(), Configuration also exposes data stored in
                META-INF/validation.xml
            </text>
        </assertion>
        <assertion id="c">
            <text>Using addMapping(), additional constraint mapping XML descriptors can be added to
                the configuration
            </text>
        </assertion>
        <assertion id="d">
            <text>Streams not supporting the mark() and reset() methods will be wrapped with an
                InputStream implementation supporting these methods by the Bean Validation provider
                in order to allow the streams to be read several times.
            </text>
        </assertion>
        <assertion id="e">
            <text>It is legal to invoke buildValidatorFactory() several times, e.g. in order to
                retrieval several ValidatorFactory instances with a slightly different configuration
                (see ).
            </text>
        </assertion>
        <assertion id="f">
            <text>A Bean Validation provider must define a sub interface of Configuration uniquely
                identifying the provider.
            </text>
        </assertion>
        <assertion id="g" testable="false">
            <text>Streams represented in the XML configuration and opened by the Configuration
                implementation must be closed by the Configuration implementation after the
                ValidatorFactory creation (or if an exception occurs).
            </text>
        </assertion>
        <assertion id="h" testable="false">
            <text>If no ValidationProviderResolver instance has been specified, the default
                ValidationProviderResolver is used.
            </text>
        </assertion>
    </section>
    <section id="5.5.4" title="ValidationProvider and ValidationProviderResolver"/>
    <section id="5.5.4.1" title="ValidationProviderResolver">
        <assertion id="a">
            <text>ValidationProviderResolver returns the list of Bean Validation providers available
                at runtime and more specifically a ValidationProvider instance for each provider
                available in the context.
            </text>
        </assertion>
        <assertion id="b" testable="false">
            <text>Implementations must be thread-safe.</text>
        </assertion>
        <assertion id="c">
            <text>Bean Validation providers must supply a service provider configuration file by
                creating a text file javax.validation.spi.ValidationProvider and placing it in the
                META-INF/services directory of one of its jar files.
            </text>
        </assertion>
    </section>
    <section id="5.5.4.2" title="ValidationProvider">
        <assertion id="a">
            <text>A client can request a specific Bean Validation provider by using &lt;T extends
                Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
                Validation.byProvider(Class&lt;U&gt;) or by defining the provider in the XML
                configuration file.
            </text>
        </assertion>
        <assertion id="b">
            <text>The provider discovery mechanism uses the following algorithm: Retrieve available
                providers using ValidationProviderResolver.getValidationProviders(). The first
                ValidationProvider matching the requested provider is returned. Providers are
                evaluated in the order they are returned by ValidationProviderResolver. A provider
                instance is considered matching if it is assignable to the requested provider class.
            </text>
        </assertion>
        <assertion id="c">
            <text>When the default Bean Validation provider is requested, the first
                ValidationProvider returned by the ValidationProviderResolver strategy is returned.
            </text>
        </assertion>
        <assertion id="d">
            <text>Every Bean Validation provider must provide a ValidationProvider implementation
                containing a public no-arg constructor
            </text>
        </assertion>
        <assertion id="e">
            <text>If a problem occurs while building the ValidatorFactory, a ValidationException is
                raised.
            </text>
        </assertion>
    </section>
    <section id="5.5.5" title="Validation">
        <assertion id="a">
            <text>The first entry point, buildDefaultValidatorFactory(), is considered to be the
                default ValidatorFactory and is equivalent to the ValidatorFactory returned by
                Validation.byDefaultProvider().configure().buildValidatorFactory().
            </text>
        </assertion>
        <assertion id="b">
            <text>The second entry point lets the client provide a custom
                ValidationProviderResolution instance. This instance is passed to GenericBootstrap.
                GenericBootstrap builds a generic Configuration using the first ValidationProvider
                returned by ValidationProviderResolution and calling
                ValidationProvider.createGenericConfiguration(BootstrapState state).
            </text>
        </assertion>
        <assertion id="c">
            <text>The last entry point lets the client define the specific Bean Validation provider
                requested as well as a custom ValidationProviderResolver implementation if needed.
                The entry point method, Validation.byProvider(Class&lt;U&gt; providerType), takes
                the provider specific ValidationProvider implementation type and returns a
                ProviderSpecificBootstrap object that guarantees to return an instance of the
                specific Configuration sub interface.
            </text>
        </assertion>
        <assertion id="d">
            <text>The Validation implementation must not contain any non private attribute or method
                aside from the three public static bootstrap methods
            </text>
        </assertion>
        <assertion id="e">
            <text>The bootstrap implementation must ensure it can bootstrap third party providers.
            </text>
        </assertion>
        <assertion id="f">
            <text>When building the Configuration object, if the ValidationProviderResolver either
                fails or if the expected provider is not found, a ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="5.5.6" title="XML Configuration: META-INF/validation.xml">
        <assertion id="a">
            <text>Unless explicitly ignored by calling Configuration.ignoreXMLConfiguration(), a
                Configuration takes into account the configuration available in
                META-INF/validation.xml.
            </text>
        </assertion>
        <assertion id="b">
            <text>This configuration file is optional</text>
        </assertion>
        <assertion id="c" testable="false">
            <text>If more than one META-INF/validation.xml file is found in the classpath, a
                ValidationException is raised.
            </text>
        </assertion>
        <assertion id="d">
            <text>Unless stated otherwise, XML based configuration settings are overridden by values
                explicitly set via the Configuration API.
            </text>
        </assertion>
        <assertion id="e">
            <text>default-provider: represents the class name of the provider specific
                ValidationProvider implementation class. If defined, the specific provider is used
            </text>
        </assertion>
        <assertion id="f">
            <text>message-interpolator: represents the fully qualified class name of the
                MessageInterpolator implementation. When defined in XML, the implementation must
                have a public no-arg constructor.
            </text>
        </assertion>
        <assertion id="g">
            <text>traversable-resolver: represents the fully qualified class name of the
                TraversableResolver implementation. When defined in XML, the implementation must
                have a public no-arg constructor.
            </text>
        </assertion>
        <assertion id="h">
            <text>constraint-validator-factory: represents the fully qualified class name of the
                ConstraintValidatorFactory implementation. When defined in XML, the implementation
                must have a public no-arg constructor.
            </text>
        </assertion>
        <assertion id="i">
            <text>parameter-name-provider: represents the fully qualified class name of the
                ParameterNameProvider implementation. When defined in XML, the implementation must
                have a public no-arg constructor.
            </text>
        </assertion>
        <assertion id="j">
            <text>message-interpolator, traversable-resolver, constraint-validator-factory and
                parameter-name-provider are optional.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="k">
            <text>constraint-mapping: represents the resource path of an XML mapping file.</text>
        </assertion>
        <assertion id="l">
            <text>More than one constraint-mapping element can be present.</text>
        </assertion>
        <assertion id="m">
            <text>Mappings provided via Configuration.addMapping(InputStream) are added to the list
                of mappings described via constraint-mapping.
            </text>
        </assertion>
        <assertion id="n" testable="false">
            <text>The namespace javax.validation is reserved for use by this specification.</text>
        </assertion>
        <assertion id="o" testable="false">
            <text>Properties defined via Configuration.addProperty(String, String) are added to the
                properties defined via property.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="p" testable="false">
            <text>If a property with the same name are defined in both XML and via the programmatic
                API, the value provided via programmatic API has priority.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="q">
            <text>If a public no-arg constructor is missing, a ValidationException is raised during
                the Configuration.buildValidatorFactory() call.
            </text>
        </assertion>
    </section>
    <section id="5.5.7" title="Bootstrapping considerations">
        <assertion id="a" testable="false">
            <text>ValidatorFactory is a thread-safe object that should be built once per deployment
                unit
            </text>
        </assertion>
        <assertion id="b" testable="false">
            <text>Validator is a thread-safe and lightweight object which can be cached by the
                ValidatorFactory instance.
            </text>
        </assertion>
    </section>
    <section id="6" title="Constraint metadata request APIs"/>
    <section id="6.1" title="Validator">
        <assertion id="a">
            <text>getConstraintsForClass returns a BeanDescriptor object describing the bean level
                constraints (see 4.1.1) and providing access to the property level constraints
                metadata.
            </text>
        </assertion>
        <assertion id="b">
            <text>An IllegalArgumentException is raised if the clazz parameter is null.</text>
        </assertion>
        <assertion id="c">
            <text>If a constraint definition or declaration hosted by the requested class (or any of
                it's superclasses and interfaces according to the constraint propagation rules) is
                invalid, a ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="6.2" title="ElementDescriptor">
        <assertion id="a">
            <text>getElementClass returns either the object type for a class, or the returned type
                for a property.
            </text>
        </assertion>
        <assertion id="b">
            <text>getConstraintDescriptors returns all the ConstraintDescriptors (see 6.8) hosted on
                the given element in the class hierarchy, each ConstraintDescriptor describing one
                of the constraints declared on the given element.
            </text>
        </assertion>
        <assertion id="c">
            <text>hasConstraints returns true if the given element (class, field or property) in the
                class hierarchy holds at least one constraint declaration.
            </text>
        </assertion>
        <assertion id="d">
            <text>getKind returns the concrete type of the given element.</text>
        </assertion>
        <assertion id="e">
            <text>The method as returns the given element casted down to one of the specific
                descriptor types, e.g. BeanDescriptor, PropertyDescriptor etc.
            </text>
        </assertion>
        <assertion id="f">
            <text>unorderedAndMatchingGroups restricts to the ConstraintDescriptors (see 6.8)
                matching the set of groups passed as parameters and present on the element. Order is
                not respected but group inheritance and inheritance via sequence (including the
                Default group overriding at the class level) are honored.
            </text>
        </assertion>
        <assertion id="g">
            <text>declaredOn lets you restrict the list of element types constraints are hosted
                on.
            </text>
        </assertion>
        <assertion id="h">
            <text>lookingAt lets you restrict which constraints are considered. Either constraints
                belonging to the element but hosted on the class represented by BeanDescritptor
                (Scope.LOCAL_ELEMENT), or constraints belonging to the element but hosted anywhere
                in the class hierarchy (Scope.HIERARCHY).
            </text>
        </assertion>
    </section>
    <section id="6.3" title="BeanDescriptor">
        <assertion id="a">
            <text>isBeanConstrained returns true if the given class (and superclasses and
                interfaces) hosts at least one validation declaration (either constraint or @Valid
                annotation).
            </text>
        </assertion>
        <assertion id="b">
            <text>getConstraintsForProperty returns a PropertyDescriptor object describing the
                property level constraints (See 4.1.2). The property is uniquely identified by its
                name as per the JavaBeans convention: field level and getter level constraints of
                the given name are all returned.
            </text>
        </assertion>
        <assertion id="c">
            <text>An IllegalArgumentException is raised if the propertyName parameter is null.
            </text>
        </assertion>
        <assertion id="d">
            <text>getConstraintsForMethod returns a MethodDescriptor object describing the method
                constraints of the given method. The method is uniquely identified by its name and
                the types of its parameters.
            </text>
        </assertion>
        <assertion id="e">
            <text>getConstrainedMethods returns the MethodDescriptors of the methods having at least
                one constraint or cascaded parameter or return value.
            </text>
        </assertion>
        <assertion id="f">
            <text>getConstraintsForConstructor returns a ConstructorDescriptor ojbect describing the
                method constraints of the given constructor. The constructor is uniquely identified
                by its name and the types of its parameters.
            </text>
        </assertion>
        <assertion id="g">
            <text>getConstrainedConstructors returns the ConstructorDescriptors of the constructors
                having at least one constraint or cascaded parameter or return value.
            </text>
        </assertion>
    </section>
    <section id="6.4" title="PropertyDescriptor">
        <assertion id="a">
            <text>The isCascaded method returns true if the property is marked with @Valid.</text>
        </assertion>
        <assertion id="b">
            <text>getPropertyName returns the property name as described in 5.2.</text>
        </assertion>
    </section>
    <section id="6.5" title="ExecutableDescriptor, MethodDescriptor and ConstructorDescriptor">
        <assertion id="a">
            <text>getName() returns the name of the represented method (e.g. "placeOrder")
                respectively the non-qualified name of the declaring class of the represented
                constructor (e.g. "OrderService").
            </text>
        </assertion>
        <assertion id="b">
            <text>getParameterDescriptors() returns a list of ParameterDescriptors representing the
                method's or constructor's parameters in their natural order. An empty list will be
                returned in case the method or constructor has no parameters.
            </text>
        </assertion>
        <assertion id="c">
            <text>getReturnValueDescriptor() returns a descriptor for the method's or constructor's
                return value or null if it has no return value.
            </text>
        </assertion>
        <assertion id="d">
            <text>isConstrainedOnParameters() returns true if any of the parameters is constrained
                or cascaded or if the represented executable has at least one cross-parameter
                constraint. Returns false if there is no parameter.
            </text>
        </assertion>
        <assertion id="e">
            <text>isConstrainedOnReturnValue() returns true if the return value is constrained or
                cascaded. Returns false if there is no return value.
            </text>
        </assertion>
        <assertion id="f">
            <text>The methods hasConstraints(), getConstraintDescriptors() and findConstraints()
                defined on ElementDescriptor are redefined to take cross-parameter constraints into
                account only. Constraint descriptors for individual parameters can be obtained from
                the corresponding ParameterMetaData object, while constraint descriptors for the
                return value can be obtained from ReturnValueDescriptor.
            </text>
        </assertion>
    </section>
    <section id="6.6" title="ParameterDescriptor">
        <assertion id="a">
            <text>getIndex() returns the index of the represented parameter within the parameter
                array of the method or constructor holding it.
            </text>
        </assertion>
        <assertion id="b">
            <text>getName() returns the name of the represented parameter.</text>
        </assertion>
        <assertion id="c">
            <text>isCascaded() returns true, if the represented parameter is marked for cascaded
                validation, false otherwise.
            </text>
        </assertion>
    </section>
    <section id="6.7" title="ReturnValueDescriptor">
        <assertion id="a">
            <text>isCascaded() returns true, if the represented return value is marked for cascaded
                validation, false otherwise.
            </text>
        </assertion>
    </section>
    <section id="6.8" title="ConstraintDescriptor">
        <assertion id="a">
            <text>If ConstraintDescriptor represents a composing annotation (see 3.3), the returned
                annotation must reflect parameter overriding.
            </text>
        </assertion>
        <assertion id="b">
            <text>getAttributes returns a map containing the annotation attribute names as a key,
                and the annotation attribute values as a value
            </text>
        </assertion>
        <assertion id="c">
            <text>If ConstraintDescriptor represents a composing annotation (see 3.3), the returned
                Map must reflect attribute overriding.
            </text>
        </assertion>
        <assertion id="d">
            <text>getGroups returns the groups the constraint is supposed to be applied upon.</text>
        </assertion>
        <assertion id="e">
            <text>If no group is set on the constraint declaration, the Default group is returned.
            </text>
        </assertion>
        <assertion id="f">
            <text>The groups of a composing constraint are the groups of the composed constraint.
            </text>
        </assertion>
        <assertion id="g">
            <text>getPayload returns the payloads associated to the constraint or an empty set if
                none.
            </text>
        </assertion>
        <assertion id="h">
            <text>The payload from the main constraint annotation is inherited by the composing
                annotations.
            </text>
        </assertion>
        <assertion id="i">
            <text>Any payload definition on a composing annotation is ignored.</text>
        </assertion>
        <assertion id="j">
            <text>isReportAsSingleViolation returns true if the constraint is annotated with
                @ReportAsSingleViolation.
            </text>
        </assertion>
        <assertion id="k">
            <text>getComposingConstraints return a set of composing ConstraintDescriptors where each
                descriptor describes a composing constraint.
            </text>
        </assertion>
    </section>
    <section id="7" title="Built-in Constraint definitions">
        <assertion id="a">
            <text>Each Bean Validation provider must recognize built-in constraint annotations as
                valid constraint definitions and provide compliant constraint implementations for
                each.
            </text>
        </assertion>
        <assertion id="b">
            <text>The built-in constraint validation implementation is having a lower priority than
                an XML mapping definition.
            </text>
        </assertion>
        <assertion id="c">
            <text>@Null constraint</text>
        </assertion>
        <assertion id="d">
            <text>@NotNull constraint</text>
        </assertion>
        <assertion id="e">
            <text>@AssertTrue constraint</text>
        </assertion>
        <assertion id="f">
            <text>@AssertFalse constraint</text>
        </assertion>
        <assertion id="g">
            <text>@Min constraint</text>
        </assertion>
        <assertion id="h">
            <text>@Max constraint</text>
        </assertion>
        <assertion id="i">
            <text>@DecimalMin constraint</text>
        </assertion>
        <assertion id="j">
            <text>@DecimalMax constraint</text>
        </assertion>
        <assertion id="k">
            <text>@Size constraint</text>
        </assertion>
        <assertion id="l">
            <text>@Digits constraint</text>
        </assertion>
        <assertion id="m">
            <text>@Past constraint</text>
        </assertion>
        <assertion id="n">
            <text>@Future constraint</text>
        </assertion>
        <assertion id="o">
            <text>@Pattern constraint</text>
        </assertion>
    </section>
    <section id="8" title="XML deployment descriptor">
        <assertion id="a">
            <text>If an XML descriptor does not validate against the corresponding XSD file, a
                ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="8.1" title="Constraint definition and declaration">
        <assertion id="a">
            <text>Specifically when exploring metadata, the Bean Validation provider must ensure
                that an annotation instance corresponding to the XML declaration is provided via
                ConstraintDescriptor.getAnnnotation().
            </text>
        </assertion>
        <assertion id="b">
            <text>A given class must not be described more than once amongst all the XML mapping
                descriptors.
            </text>
        </assertion>
        <assertion id="c">
            <text>A given field or getter must not be described more than once on a given class
                description.
            </text>
        </assertion>
        <assertion id="d">
            <text>A given constraint definition must not be overridden more than once amongst all
                the XML mapping descriptors.
            </text>
        </assertion>
        <assertion id="e">
            <text>If any of these rule is violated in a given validation deployment, a
                ValidationException is raised during the creation of the ValidatorFactory.
            </text>
        </assertion>
    </section>
    <section id="8.1.1" title="Constraint declaration in XML">
        <assertion id="a">
            <text>If default-package is set, all unqualified class names (including annotations) are
                considered part of the package described by default-package.
            </text>
        </assertion>
        <assertion id="b">
            <text>A given JavaBean is described by the bean element.</text>
        </assertion>
        <assertion id="c">
            <text>The name of the class is mandatory.</text>
        </assertion>
        <assertion id="d">
            <text>By default, all constraint declarations expressed via annotation are ignored for
                classes described in XML.
            </text>
        </assertion>
        <assertion id="e">
            <text>You can force Bean Validation to consider both annotations and XML constraint
                declarations by using ignore-annotation="false" on bean.
            </text>
        </assertion>
        <assertion id="f">
            <text>If the name of the class does refer to a class not present in in the classpath, a
                ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="8.1.1.1" title="Class-level overriding">
        <assertion id="a">
            <text>If ignore-annotations is declared, Bean Validation must honor the explicit value
                for this element.
            </text>
        </assertion>
        <assertion id="b">
            <text>If not declared, the default value defined in the encapsulating bean element is
                considered.
            </text>
        </assertion>
        <assertion id="c">
            <text>When ignore-annotations is true, class-level Bean Validation annotations are
                ignored for this class (including the @GroupSequence).
            </text>
        </assertion>
        <assertion id="d">
            <text>Constraints declared in XML and constraints declared in annotations are added and
                form the list of class-level declared constraints.
            </text>
        </assertion>
        <assertion id="e">
            <text>@GroupSequence is considered unless group-sequence element is explicitly used.
            </text>
        </assertion>
    </section>
    <section id="8.1.1.2" title="Field-level overriding">
        <assertion id="a">
            <text>If ignore-annotations is declared, Bean Validation must honor the explicit value
                for this element.
            </text>
        </assertion>
        <assertion id="b">
            <text>If not declared, the default value defined in the encapsulating bean element is
                considered.
            </text>
        </assertion>
        <assertion id="c">
            <text>When ignore-annotations is true, field-level Bean Validation annotations on the
                targeted field are ignored (including the @Valid).
            </text>
        </assertion>
        <assertion id="d">
            <text>Constraints declared in XML and constraints declared in annotations are added and
                form the list of field-level declared constraints.
            </text>
        </assertion>
        <assertion id="e">
            <text>Note that the only way to disable cascading on a field marked as @Valid is to use
                ignore-annotations=true.
            </text>
        </assertion>
        <assertion id="f">
            <text>If the name of the field does not correspond to a field in the given bean a
                ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="8.1.1.3" title="Property-level overriding">
        <assertion id="a">
            <text>The name attribute correspond to the name of the property considered as defined in
                4.1.2 (for example a getter String getAge() would have &lt;getter name="age"/&gt; as
                a corresponding descriptor). If ignore-annotations is declared, Bean Validation must
                honor the explicit value for this element.
            </text>
        </assertion>
        <assertion id="b">
            <text>If not declared, the default value defined in the encapsulating bean element is
                considered.
            </text>
        </assertion>
        <assertion id="c">
            <text>When ignore-annotations is true, property-level Bean Validation annotations on the
                targeted property are ignored (including the @Valid).
            </text>
        </assertion>
        <assertion id="d">
            <text>Constraints declared in XML and constraints declared in annotations are added and
                form the list of property-level declared constraints.
            </text>
        </assertion>
        <assertion id="e">
            <text>Note that the only way to disable cascading on a property marked as @Valid is to
                use ignore-annotations=true.
            </text>
        </assertion>
        <assertion id="f">
            <text>If the name of the property does not correspond to a property in the given bean a
                ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="8.1.1.5" title="Constraint declaration">
        <assertion id="a">
            <text>The name attribute is mandatory and represents the name of the element in the
                constraint declaration.
            </text>
        </assertion>
        <assertion id="b">
            <text>Message, groups and payload are not permitted names, use the message, groups or
                payload elements instead. Otherwise a ValidationException is raised.
            </text>
            <note>Needs update</note>
        </assertion>
        <assertion id="c">
            <text>If the element represents a primitive type, a class or an enum, the string
                representation of its value is placed in the element itself.
            </text>
        </assertion>
        <assertion id="d">
            <text>If the element represents a primitive type array, a class array or an enum array,
                the string representation of each value is placed in a value element placed under
                the element itself.
            </text>
        </assertion>
        <assertion id="e">
            <text>If the element represents an annotation, the annotation element is used to
                represent the annotation and placed under element.
            </text>
        </assertion>
        <assertion id="f">
            <text>If the element represents an array of annotations, one or more annotation elements
                are placed under element.
            </text>
        </assertion>
        <assertion id="g">
            <text>Elements with default values in the annotation definition do not have to be
                represented in XML: the default value will be used in this case.
            </text>
        </assertion>
        <assertion id="h">
            <text>If an XML constraint declaration is missing mandatory elements, or if it contains
                elements not part of the constraint definition, a ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="8.1.2" title="Overriding constraint definitions in XML">
        <assertion id="a">
            <text>A constraint definition is represented by a constraint-definition element.</text>
        </assertion>
        <assertion id="b">
            <text>If include-existing-validator is set to false, ConstraintValidator defined on the
                constraint annotation are ignored.
            </text>
        </assertion>
        <assertion id="c">
            <text>If set to true, the list of ConstraintValidators described in XML are concatenated
                to the list of ConstraintValidator described on the annotation to form a new array
                of ConstraintValidator evaluated.
            </text>
        </assertion>
        <assertion id="d">
            <text>Annotation based ConstraintValidator come before XML based ConstraintValidators in
                the array.
            </text>
        </assertion>
        <assertion id="e">
            <text>The new validator list is returned by
                ConstraintDescriptor.getConstraintValidatorClasses().
            </text>
        </assertion>
    </section>
    <section id="8.1.4" title="XML Schema">
        <assertion id="a">
            <text>Implementations supporting Bean Validation 1.1 must properly parse mapping
                descriptors of Bean Validation 1.0 and 1.1.
            </text>
        </assertion>
        <assertion id="b">
            <text>If the version attribute attribute is not given, schema version 1.0 is to be
                assumed by the Bean Validation Provider.
            </text>
        </assertion>
        <assertion id="c">
            <text>In case an unknown version is given (e.g. if a mapping descriptor adhering to a
                future schema version is parsed by a Bean Validation 1.1 provider) a
                ValidationException is raised.
            </text>
        </assertion>
    </section>
    <section id="8.2" title="Configuration schema">
        <assertion id="a">
            <text>Implementations supporting Bean Validation 1.1 must properly parse configuration
                descriptors of Bean Validation 1.0 and 1.1.
            </text>
        </assertion>
        <assertion id="b">
            <text>If the version attribute attribute is not given, schema version 1.0 is to be
                assumed by the Bean Validation Provider.
            </text>
        </assertion>
        <assertion id="c">
            <text>In case an unknown version is given a ValidationException is raised.</text>
        </assertion>
    </section>
    <section id="9" title="Exception model">
        <assertion id="a">
            <text>Every (runtime) exception raised either at initialization time or execution time
                by any of the extension interfaces (ConstraintValidator, ConstraintValidatorFactory,
                MessageInterpolator, TraversableResolver, ValidationProviderResolver) is wrapped in
                a ValidationException.
            </text>
        </assertion>
    </section>
    <section id="9.2" title="Constraint definition: ConstraintDefinitionException">
        <assertion id="a">
            <text>If a constraint definition does not respect the Bean Validation rules or is
                inconsistent, a ConstraintDefinitionException is raised.
            </text>
        </assertion>
    </section>
    <section id="9.3"
             title="Constraint declaration: ConstraintDeclarationException and UnexpectedTypeException">
        <assertion id="a" testable="false">
            <text>When a constraint declaration is illegal, ConstraintDeclarationException is
                raised.
            </text>
        </assertion>
        <assertion id="b">
            <text>When the return type of a property cannot be processed for a given constraint, an
                UnexpectedTypeException is raised.
            </text>
        </assertion>
    </section>
    <section id="9.4" title="Group definition: GroupDefinitionException">
        <assertion id="a">
            <text>When a group definition is illegal, GroupDefinitionException is raised.</text>
        </assertion>
    </section>
    <section id="10" title="Integration"/>
</specification>
